import numpy as np


class NodemapStructure:
    """
    Structure of nodemap files generated by Aramis.
    """

    def __init__(
        self,
        row_length=10,
        index_coor_x=1,
        index_coor_y=2,
        index_disp_x=4,
        index_disp_y=5,
        index_eps_x=7,
        index_eps_y=8,
        index_eps_xy=9,
        strain_is_percent=True,
        is_fem=False,
    ):
        self.row_length = row_length
        self.index_coor_x = index_coor_x
        self.index_coor_y = index_coor_y
        self.index_disp_x = index_disp_x
        self.index_disp_y = index_disp_y
        self.index_eps_x = index_eps_x
        self.index_eps_y = index_eps_y
        self.index_eps_xy = index_eps_xy
        self.strain_is_percent = strain_is_percent
        self.is_fem = is_fem


class InputData:
    """Class for the import and transformation of input data from DIC nodemaps.

    Methods
        * read_header - method to import metadata from header (if ``data_file`` is provided)
        * read_data_file - method to import input data from file (if ``data_file`` is provided)

        * set_data_manually - set physical data manually instead of from nodemap file
        * transform_data - with a coordinate shift and angle rotation

        * calc_eps_vm - calculate Von Mises strain (stored as attribute)
        * calc_stresses - calculate stresses using material law
        * calc_facet_size - calculate the face size of DIC data
    """

    def __init__(
        self,
        data_file: str = None,
        nodemap_structure: NodemapStructure = NodemapStructure(),
    ):
        """Initialize input data class by reading metadata and data and calculating eps_vm (if data_file is provided).

        :param data_file: (str or None) nodemap file path (if provided the methods ``read_data_file``, ``read_header``,
                                 and ``calc_eps_vm``` are run upon initialization)
        :param nodemap_structure: (NodemapStructure) for the nodemap file import

        """
        self.data_file = data_file
        self.nodemap_structure = nodemap_structure

        # input data attributes
        self.coor_x = None
        self.coor_y = None
        self.disp_x = None
        self.disp_y = None
        self.eps_x = None
        self.eps_y = None
        self.eps_xy = None
        self.eps_vm = None
        self.sig_x = None
        self.sig_y = None
        self.sig_xy = None
        self.sig_vm = None

        # meta data attributes
        self.force = None
        self.cycles = None
        self.displacement = None
        self.potential = None  # potential drop
        self.cracklength = None
        self.time = None

        # methods called when initialized
        if data_file is not None:
            self.read_data_file()
            self.read_header()
            self.calc_eps_vm()

    def read_header(self):
        """
        Get meta data by reading from header.
        """
        meta_keys = [
            "force",
            "cycles",
            "displacement",
            "potential",
            "cracklength",
            "dms_1",
            "dms_2",
            "time",
            "x",
            "y",
            "z",
            "alignment_translation_x",
            "alignment_translation_y",
            "alignment_translation_z",
        ]
        with open(self.data_file, "r", errors="ignore", encoding="utf-8") as input_data:
            for line in input_data:
                for meta_key in meta_keys:
                    if "# " + meta_key in line:
                        meta_stripped = line.split(":")[
                            -1
                        ].strip()  # can be str(float) or 'None'
                        if meta_stripped == "None":
                            meta_value = None
                        else:
                            meta_value = float(meta_stripped)

                        # set class instance attribute
                        setattr(self, meta_key, meta_value)

                        meta_keys.remove(meta_key)
                        break
                if len(meta_keys) == 0:
                    break

    def read_data_file(self):
        """
        Read data from nodemap file.
        """

        df = np.genfromtxt(self.data_file, delimiter=";", encoding="windows-1252")
        np_df = np.asarray(df, dtype=np.float64)
        # cut nans (necessary since version 2020)
        nodemap_data = self._cut_nans(np_df)

        self.coor_x = nodemap_data[:, self.nodemap_structure.index_coor_x]
        self.coor_y = nodemap_data[:, self.nodemap_structure.index_coor_y]
        self.disp_x = nodemap_data[:, self.nodemap_structure.index_disp_x]
        self.disp_y = nodemap_data[:, self.nodemap_structure.index_disp_y]

        if self.nodemap_structure.strain_is_percent:
            self.eps_x = nodemap_data[:, self.nodemap_structure.index_eps_x] / 100.0
            self.eps_y = nodemap_data[:, self.nodemap_structure.index_eps_y] / 100.0
        else:
            self.eps_x = nodemap_data[:, self.nodemap_structure.index_eps_x]
            self.eps_y = nodemap_data[:, self.nodemap_structure.index_eps_y]
        self.eps_xy = nodemap_data[:, self.nodemap_structure.index_eps_xy]

        if self.nodemap_structure.is_fem:
            self.eps_xy /= 2  # Currently ANSYS returns the engineering strain gamma_xy = 2 * eps_xy
            self.sig_x = nodemap_data[:, 11]
            self.sig_y = nodemap_data[:, 12]
            self.sig_xy = nodemap_data[:, 13]
            self.sig_vm = np.sqrt(
                self.sig_x**2
                + self.sig_y**2
                - self.sig_x * self.sig_y
                + 3 * self.sig_xy**2
            )

    def set_data_manually(
        self, coor_x, coor_y, disp_x, disp_y, eps_x, eps_y, eps_xy, eps_vm=None
    ):
        """
        Manually set data, e.g. for in-situ calculation in aramis software.

        :param coor_x: (np.array) of x coordinates
        :param coor_y: (np.array) of y coordinates
        :param disp_x: (np.array) of x displacements
        :param disp_y: (np.array) of y displacements
        :param eps_x: (np.array) of strain eps_x
        :param eps_y: (np.array) of strain eps_y
        :param eps_xy: (np.array) of strain eps_xy
        :param eps_vm: (np.array) of Von-Mises strain (if provided)

        """
        if eps_vm is None:
            df = np.asarray(
                [coor_x, coor_y, disp_x, disp_y, eps_x, eps_y, eps_xy]
            ).transpose()
        else:
            df = np.asarray(
                [coor_x, coor_y, disp_x, disp_y, eps_x, eps_y, eps_xy, eps_vm]
            ).transpose()
        df = self._cut_nans(df)

        self.coor_x = df[:, 0]  # coor_x
        self.coor_y = df[:, 1]  # coor_y
        self.disp_x = df[:, 2]  # disp_x
        self.disp_y = df[:, 3]  # disp_y
        self.eps_x = df[:, 4]  # eps_x
        self.eps_y = df[:, 5]  # eps_y
        self.eps_xy = df[:, 6]  # eps_xy
        if eps_vm is not None:
            self.eps_vm = df[:, 7]  # eps_vm
        else:
            self.eps_vm = []

    def transform_data(self, x_shift, y_shift, angle):
        """
        Transform data by shift and rotation.

        :param x_shift: (float) shift of x-coordinate
        :param y_shift: (float) shift of y-coordinate
        :param angle: (float) rotation angle in degrees between 0° and 360°

        """
        angle *= np.pi / 180.0
        trafo_matrix = np.array(
            [[np.cos(angle), np.sin(angle)], [-np.sin(angle), np.cos(angle)]]
        )
        # coordinates
        self.coor_x -= x_shift
        self.coor_y -= y_shift
        # transformations
        self.coor_x, self.coor_y = np.dot(trafo_matrix, [self.coor_x, self.coor_y])
        self.disp_x, self.disp_y = np.dot(trafo_matrix, [self.disp_x, self.disp_y])
        strain_tensor = np.array([[self.eps_x, self.eps_xy], [self.eps_xy, self.eps_y]])
        strain_tensor = np.transpose(strain_tensor, (2, 0, 1))
        strain_tensor = np.dot(strain_tensor, trafo_matrix.T)
        strain_tensor = np.transpose(strain_tensor, (1, 2, 0))
        strain_tensor = np.dot(trafo_matrix, strain_tensor)
        self.eps_x = strain_tensor[0, 0, :]
        self.eps_y = strain_tensor[1, 1, :]
        self.eps_xy = strain_tensor[0, 1, :]
        stress_tensor = np.array([[self.sig_x, self.sig_xy], [self.sig_xy, self.sig_y]])
        stress_tensor = np.transpose(stress_tensor, (2, 0, 1))
        stress_tensor = np.dot(stress_tensor, trafo_matrix.T)
        stress_tensor = np.transpose(stress_tensor, (1, 2, 0))
        stress_tensor = np.dot(trafo_matrix, stress_tensor)
        self.sig_x = stress_tensor[0, 0, :]
        self.sig_y = stress_tensor[1, 1, :]
        self.sig_xy = stress_tensor[0, 1, :]
        self.sig_vm = self._calc_sig_vm()

    def calc_eps_vm(self):
        """
        Calculate and return Von Mises equivalent strain.
        """

        self.eps_vm = (
            2
            / 3
            * np.sqrt(
                3 / 2 * (self.eps_x**2 + self.eps_y**2) + 3 * self.eps_xy**2
            )
        )
        return self.eps_vm

    def calc_stresses(self, material):
        """
        Calculates and attaches the stresses using linear elasticity with the provided parameters.

        :param material: (MaterialProperties obj) to get stiffness matrix
        """
        self.sig_x, self.sig_y, self.sig_xy = np.dot(
            material.stiffness_matrix, [self.eps_x, self.eps_y, self.eps_xy]
        )
        self.sig_vm = self._calc_sig_vm()

    def calc_facet_size(self) -> float:
        """
        Returns DIC facet size.
        """
        return np.min(
            np.sqrt(
                (self.coor_x[1:] - self.coor_x[0]) ** 2.0
                + (self.coor_y[1:] - self.coor_y[0]) ** 2.0
            )
        )

    def _calc_sig_vm(self):
        """
        Returns the Von Mises stress.
        """
        return np.sqrt(
            self.sig_x**2
            + self.sig_y**2
            - self.sig_x * self.sig_y
            + 3 * self.sig_xy**2
        )

    @staticmethod
    def _cut_nans(df):
        """
        Reads an array and deletes each row containing any nan value.
        """
        cut_nans_array = df[~np.isnan(df).any(axis=1)]
        return cut_nans_array
